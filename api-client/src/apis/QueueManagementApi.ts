/* tslint:disable */
/* eslint-disable */
/**
 * Mediva API
 * Specification of the Mediva API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: admin@mediva.in
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddPatientResponse,
  AddPatientToQueueRequest,
  MarkDoneRequest,
  MarkDoneResponse,
  ModelApiResponse,
  MovePatientResponse,
  PatientQueueEntry,
  RemovePatientResponse,
} from '../models/index';

export interface AddPatientToQueueOperationRequest {
    addPatientToQueueRequest: AddPatientToQueueRequest;
}

export interface GetCurrentQueueRequest {
    terminalId: number;
}

export interface HandleDelayRequest {
    delayMinutes: number;
    terminalId: number;
}

export interface IsQueuePausedRequest {
    terminalId: number;
}

export interface MarkDoneStatusRequest {
    markDoneRequest: MarkDoneRequest;
}

export interface MovePatientByRequest {
    patientId: string;
    delta: number;
    terminalId: number;
}

export interface PauseQueueRequest {
    terminalId: number;
}

export interface RemovePatientFromQueueRequest {
    patientId: string;
    terminalId: number;
}

export interface ResumeQueueRequest {
    terminalId: number;
}

/**
 * QueueManagementApi - interface
 * 
 * @export
 * @interface QueueManagementApiInterface
 */
export interface QueueManagementApiInterface {
    /**
     * Adds a patient to the end of the queue with an estimated start time. The patient will be notified via WhatsApp after successful addition. Check-in is only allowed during working hours if enforced. 
     * @summary Add patient to queue
     * @param {AddPatientToQueueRequest} addPatientToQueueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    addPatientToQueueRaw(requestParameters: AddPatientToQueueOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddPatientResponse>>;

    /**
     * Adds a patient to the end of the queue with an estimated start time. The patient will be notified via WhatsApp after successful addition. Check-in is only allowed during working hours if enforced. 
     * Add patient to queue
     */
    addPatientToQueue(addPatientToQueueRequest: AddPatientToQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddPatientResponse>;

    /**
     * Returns the current queue entries in order with accurate start times. The response includes all patients currently in the queue. 
     * @summary Get current queue
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    getCurrentQueueRaw(requestParameters: GetCurrentQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PatientQueueEntry>>>;

    /**
     * Returns the current queue entries in order with accurate start times. The response includes all patients currently in the queue. 
     * Get current queue
     */
    getCurrentQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PatientQueueEntry>>;

    /**
     * Applies a delay to all patients except the head of the queue. All affected patients are notified via WhatsApp about the updated times. 
     * @summary Handle delay
     * @param {number} delayMinutes Delay in minutes
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    handleDelayRaw(requestParameters: HandleDelayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PatientQueueEntry>>>;

    /**
     * Applies a delay to all patients except the head of the queue. All affected patients are notified via WhatsApp about the updated times. 
     * Handle delay
     */
    handleDelay(delayMinutes: number, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PatientQueueEntry>>;

    /**
     * Checks if the queue is currently paused by reading the Redis flag. Returns true if paused, false otherwise. 
     * @summary Check queue pause status
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    isQueuePausedRaw(requestParameters: IsQueuePausedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>>;

    /**
     * Checks if the queue is currently paused by reading the Redis flag. Returns true if paused, false otherwise. 
     * Check queue pause status
     */
    isQueuePaused(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean>;

    /**
     * Updates the markDone status for a patient in the queue (0: no test done, 1: echo done, 2: consultation done, 3: both done). Returns the updated patient queue entry. 
     * @summary Mark done status for patient in queue
     * @param {MarkDoneRequest} markDoneRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    markDoneStatusRaw(requestParameters: MarkDoneStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkDoneResponse>>;

    /**
     * Updates the markDone status for a patient in the queue (0: no test done, 1: echo done, 2: consultation done, 3: both done). Returns the updated patient queue entry. 
     * Mark done status for patient in queue
     */
    markDoneStatus(markDoneRequest: MarkDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkDoneResponse>;

    /**
     * Moves a patient forward or backward by a specified number of positions in the queue. Positive delta moves forward, negative delta moves backward. All downstream patients\' estimated start times are recalculated. The patient is notified via WhatsApp about the change. 
     * @summary Move patient by delta positions
     * @param {string} patientId Unique identifier for the patient
     * @param {number} delta Number of positions to move (positive for forward, negative for backward)
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    movePatientByRaw(requestParameters: MovePatientByRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MovePatientResponse>>;

    /**
     * Moves a patient forward or backward by a specified number of positions in the queue. Positive delta moves forward, negative delta moves backward. All downstream patients\' estimated start times are recalculated. The patient is notified via WhatsApp about the change. 
     * Move patient by delta positions
     */
    movePatientBy(patientId: string, delta: number, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MovePatientResponse>;

    /**
     * Pauses the queue by setting a Redis flag. When paused, no new patients can be added and existing patients cannot proceed. 
     * @summary Pause queue
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    pauseQueueRaw(requestParameters: PauseQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Pauses the queue by setting a Redis flag. When paused, no new patients can be added and existing patients cannot proceed. 
     * Pause queue
     */
    pauseQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

    /**
     * Removes a patient from the queue and adjusts all later patients\' estimated start times. The removed patient entry is returned for confirmation. 
     * @summary Remove patient from queue
     * @param {string} patientId Unique identifier for the patient
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    removePatientFromQueueRaw(requestParameters: RemovePatientFromQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemovePatientResponse>>;

    /**
     * Removes a patient from the queue and adjusts all later patients\' estimated start times. The removed patient entry is returned for confirmation. 
     * Remove patient from queue
     */
    removePatientFromQueue(patientId: string, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemovePatientResponse>;

    /**
     * Resumes the paused queue, allowing patients to proceed normally. Clears the pause flag in Redis. 
     * @summary Resume queue
     * @param {number} terminalId Unique identifier for the terminal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueManagementApiInterface
     */
    resumeQueueRaw(requestParameters: ResumeQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     * Resumes the paused queue, allowing patients to proceed normally. Clears the pause flag in Redis. 
     * Resume queue
     */
    resumeQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class QueueManagementApi extends runtime.BaseAPI implements QueueManagementApiInterface {

    /**
     * Adds a patient to the end of the queue with an estimated start time. The patient will be notified via WhatsApp after successful addition. Check-in is only allowed during working hours if enforced. 
     * Add patient to queue
     */
    async addPatientToQueueRaw(requestParameters: AddPatientToQueueOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddPatientResponse>> {
        if (requestParameters['addPatientToQueueRequest'] == null) {
            throw new runtime.RequiredError(
                'addPatientToQueueRequest',
                'Required parameter "addPatientToQueueRequest" was null or undefined when calling addPatientToQueue().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/add-queue`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['addPatientToQueueRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds a patient to the end of the queue with an estimated start time. The patient will be notified via WhatsApp after successful addition. Check-in is only allowed during working hours if enforced. 
     * Add patient to queue
     */
    async addPatientToQueue(addPatientToQueueRequest: AddPatientToQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddPatientResponse> {
        const response = await this.addPatientToQueueRaw({ addPatientToQueueRequest: addPatientToQueueRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Returns the current queue entries in order with accurate start times. The response includes all patients currently in the queue. 
     * Get current queue
     */
    async getCurrentQueueRaw(requestParameters: GetCurrentQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PatientQueueEntry>>> {
        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling getCurrentQueue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/get-queue`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the current queue entries in order with accurate start times. The response includes all patients currently in the queue. 
     * Get current queue
     */
    async getCurrentQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PatientQueueEntry>> {
        const response = await this.getCurrentQueueRaw({ terminalId: terminalId }, initOverrides);
        return await response.value();
    }

    /**
     * Applies a delay to all patients except the head of the queue. All affected patients are notified via WhatsApp about the updated times. 
     * Handle delay
     */
    async handleDelayRaw(requestParameters: HandleDelayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PatientQueueEntry>>> {
        if (requestParameters['delayMinutes'] == null) {
            throw new runtime.RequiredError(
                'delayMinutes',
                'Required parameter "delayMinutes" was null or undefined when calling handleDelay().'
            );
        }

        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling handleDelay().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['delayMinutes'] != null) {
            queryParameters['delayMinutes'] = requestParameters['delayMinutes'];
        }

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/delay`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Applies a delay to all patients except the head of the queue. All affected patients are notified via WhatsApp about the updated times. 
     * Handle delay
     */
    async handleDelay(delayMinutes: number, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PatientQueueEntry>> {
        const response = await this.handleDelayRaw({ delayMinutes: delayMinutes, terminalId: terminalId }, initOverrides);
        return await response.value();
    }

    /**
     * Checks if the queue is currently paused by reading the Redis flag. Returns true if paused, false otherwise. 
     * Check queue pause status
     */
    async isQueuePausedRaw(requestParameters: IsQueuePausedRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<boolean>> {
        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling isQueuePaused().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/isPaused`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<boolean>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Checks if the queue is currently paused by reading the Redis flag. Returns true if paused, false otherwise. 
     * Check queue pause status
     */
    async isQueuePaused(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<boolean> {
        const response = await this.isQueuePausedRaw({ terminalId: terminalId }, initOverrides);
        return await response.value();
    }

    /**
     * Updates the markDone status for a patient in the queue (0: no test done, 1: echo done, 2: consultation done, 3: both done). Returns the updated patient queue entry. 
     * Mark done status for patient in queue
     */
    async markDoneStatusRaw(requestParameters: MarkDoneStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MarkDoneResponse>> {
        if (requestParameters['markDoneRequest'] == null) {
            throw new runtime.RequiredError(
                'markDoneRequest',
                'Required parameter "markDoneRequest" was null or undefined when calling markDoneStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/mark-done`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['markDoneRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the markDone status for a patient in the queue (0: no test done, 1: echo done, 2: consultation done, 3: both done). Returns the updated patient queue entry. 
     * Mark done status for patient in queue
     */
    async markDoneStatus(markDoneRequest: MarkDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MarkDoneResponse> {
        const response = await this.markDoneStatusRaw({ markDoneRequest: markDoneRequest }, initOverrides);
        return await response.value();
    }

    /**
     * Moves a patient forward or backward by a specified number of positions in the queue. Positive delta moves forward, negative delta moves backward. All downstream patients\' estimated start times are recalculated. The patient is notified via WhatsApp about the change. 
     * Move patient by delta positions
     */
    async movePatientByRaw(requestParameters: MovePatientByRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MovePatientResponse>> {
        if (requestParameters['patientId'] == null) {
            throw new runtime.RequiredError(
                'patientId',
                'Required parameter "patientId" was null or undefined when calling movePatientBy().'
            );
        }

        if (requestParameters['delta'] == null) {
            throw new runtime.RequiredError(
                'delta',
                'Required parameter "delta" was null or undefined when calling movePatientBy().'
            );
        }

        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling movePatientBy().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['patientId'] != null) {
            queryParameters['patientId'] = requestParameters['patientId'];
        }

        if (requestParameters['delta'] != null) {
            queryParameters['delta'] = requestParameters['delta'];
        }

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/move`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Moves a patient forward or backward by a specified number of positions in the queue. Positive delta moves forward, negative delta moves backward. All downstream patients\' estimated start times are recalculated. The patient is notified via WhatsApp about the change. 
     * Move patient by delta positions
     */
    async movePatientBy(patientId: string, delta: number, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MovePatientResponse> {
        const response = await this.movePatientByRaw({ patientId: patientId, delta: delta, terminalId: terminalId }, initOverrides);
        return await response.value();
    }

    /**
     * Pauses the queue by setting a Redis flag. When paused, no new patients can be added and existing patients cannot proceed. 
     * Pause queue
     */
    async pauseQueueRaw(requestParameters: PauseQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling pauseQueue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/pause`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Pauses the queue by setting a Redis flag. When paused, no new patients can be added and existing patients cannot proceed. 
     * Pause queue
     */
    async pauseQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.pauseQueueRaw({ terminalId: terminalId }, initOverrides);
    }

    /**
     * Removes a patient from the queue and adjusts all later patients\' estimated start times. The removed patient entry is returned for confirmation. 
     * Remove patient from queue
     */
    async removePatientFromQueueRaw(requestParameters: RemovePatientFromQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RemovePatientResponse>> {
        if (requestParameters['patientId'] == null) {
            throw new runtime.RequiredError(
                'patientId',
                'Required parameter "patientId" was null or undefined when calling removePatientFromQueue().'
            );
        }

        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling removePatientFromQueue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['patientId'] != null) {
            queryParameters['patientId'] = requestParameters['patientId'];
        }

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/remove`;

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Removes a patient from the queue and adjusts all later patients\' estimated start times. The removed patient entry is returned for confirmation. 
     * Remove patient from queue
     */
    async removePatientFromQueue(patientId: string, terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RemovePatientResponse> {
        const response = await this.removePatientFromQueueRaw({ patientId: patientId, terminalId: terminalId }, initOverrides);
        return await response.value();
    }

    /**
     * Resumes the paused queue, allowing patients to proceed normally. Clears the pause flag in Redis. 
     * Resume queue
     */
    async resumeQueueRaw(requestParameters: ResumeQueueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['terminalId'] == null) {
            throw new runtime.RequiredError(
                'terminalId',
                'Required parameter "terminalId" was null or undefined when calling resumeQueue().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['terminalId'] != null) {
            queryParameters['terminalId'] = requestParameters['terminalId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("http-bearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/queue/resume`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resumes the paused queue, allowing patients to proceed normally. Clears the pause flag in Redis. 
     * Resume queue
     */
    async resumeQueue(terminalId: number, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.resumeQueueRaw({ terminalId: terminalId }, initOverrides);
    }

}
